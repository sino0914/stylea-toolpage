<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>3D å·§å…‹åŠ›</title>
  <style>
    body { margin: 0; overflow: hidden; background: #2e2a27; }
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #fff;
      font-size: 2em;
      background: rgba(0,0,0,0.7);
      padding: 20px 40px;
      border-radius: 15px;
      display: none;
    }
	
	#message {
	  display: none;
	  opacity: 0;
	  transition: opacity 0.5s ease;
	}
	#message.show {
	  display: block;
	  opacity: 1;
	}
  </style>
</head>
<body>
  <div id="message">ğŸ’• æƒ…äººç¯€å¿«æ¨‚ ğŸ’•</div>
  <div>
	<div id="messageIcon" style="
      position: absolute;
      bottom: 15px;
	  left: 100px;
	  font-size: 2.5em;
	  cursor: pointer;
	  user-select: none;
	">ğŸ’Œ</div>
	<div id="toggleRotate" style="
	  position: absolute;
	  bottom: 20px;
	  left: 20px;
	  font-size: 2em;
	  cursor: pointer;
	  user-select: none;
	">
	  â¸ï¸
	</div>
  </div>
  <!-- âš¡ ä½¿ç”¨èˆŠç‰ˆ three.js r124ï¼Œä¿è­‰ OrbitControls æ›åœ¨å…¨åŸŸ -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.124.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.124.0/examples/js/controls/OrbitControls.js"></script>


<script>
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // ç‡ˆå…‰
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const pointLight = new THREE.PointLight(0xffffff, 1);
  pointLight.position.set(5, 5, 5);
  scene.add(pointLight);
  const pointLight2 = new THREE.PointLight(0xffffff, 1);
  pointLight2.position.set(-5, -5, -5);
  scene.add(pointLight2);

  camera.position.z = 8;

  // OrbitControls
  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // ===============================
  // å»ºç«‹æ¢¯å½¢å·§å…‹åŠ›æ ¼å­
  // ===============================
  const chocolateGroup = new THREE.Group();

  const rows = 3;   // æ’æ•¸
  const cols = 5;   // è¡Œæ•¸
  const width = 0.8;   // åº•éƒ¨å¯¬
  const height = 0.4;  // åšåº¦
  const depth = 0.8;   // åº•éƒ¨æ·±
  const topScale = 0.7; // ä¸Šè¡¨é¢ç¸®å°æ¯”ä¾‹ (è¶Šå°è¶Šæ–œ)

  const material = new THREE.MeshStandardMaterial({
    color: 0x4b2e2e,
    roughness: 0.6,
    metalness: 0.2
  });

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      // åŸºæœ¬æ–¹å½¢
      const shape = new THREE.Shape();
      shape.moveTo(-width/2, -depth/2);
      shape.lineTo(width/2, -depth/2);
      shape.lineTo(width/2, depth/2);
      shape.lineTo(-width/2, depth/2);
      shape.lineTo(-width/2, -depth/2);

      // æ‹‰ä¼¸ (å¸¶æ–œé‚Š = ä¸Šå°ä¸‹å¤§)
      const extrudeSettings = {
        steps: 1,
        depth: height,
        bevelEnabled: true,
        bevelThickness: 0.1,
        bevelSize: (1 - topScale) * (width/2),
        bevelSegments: 1
      };

      const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      const piece = new THREE.Mesh(geometry, material);

      // å®šä½æ¯å¡Šå·§å…‹åŠ›
      piece.position.x = c * (width + 0.15);
      piece.position.y = r * (depth + 0.15);
      piece.position.z = -height/2;

      chocolateGroup.add(piece);
    }
  }
  
  // è®“æ•´å¡Šå·§å…‹åŠ›å°é½Šä¸­å¿ƒ (æ–¹ä¾¿ pivot æ—‹è½‰)
  chocolateGroup.position.x = -(cols-1) * (width+0.15) / 2;
  chocolateGroup.position.y = -(rows-1) * (depth+0.15) / 2;

  // ===============================
  // å»ºç«‹ Pivotï¼Œæ§åˆ¶æ—‹è½‰ä¸­å¿ƒ
  // ===============================
  const pivot = new THREE.Group();
  scene.add(pivot);
  pivot.add(chocolateGroup);

  // ä½ å¯ä»¥èª¿æ•´ chocolateGroup çš„åç§»ï¼Œæ”¹è®Šæ—‹è½‰ä¸­å¿ƒ
  // ä¾‹å¦‚ï¼šchocolateGroup.position.set(-2,0,0);
  
  //è®“å·§å…‹åŠ›å‚¾æ–œ
  pivot.rotation.z = 0.4;
  
  // ===============================
  // éŸ³æª”æ’­æ”¾é‚è¼¯
  // ===============================
  const audioFiles = [
    "audio0.mp3",
    "audio1.mp3",
    "audio2.mp3"
  ];
  let currentAudioIndex = 0;
  let audioPlayer = new Audio();

  function playNextAudio() {
    audioPlayer.src = audioFiles[currentAudioIndex];
    audioPlayer.play();
    currentAudioIndex = (currentAudioIndex + 1) % audioFiles.length; // æ’­åˆ°æœ€å¾Œå› 0
  }
  // ===============================
  // é»æ“Šäº‹ä»¶ â†’ æ’­æ”¾éŸ³æª” + å½ˆè·³æ•ˆæœ
  // ===============================
  const raycaster = new THREE.Raycaster();
  const mouse = new THREE.Vector2();
  window.addEventListener("click", (event) => {
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObjects(chocolateGroup.children);
    if (intersects.length > 0) {
  	  const piece = intersects[0].object;
  	  playNextAudio(); // æ’­éŸ³æª”
  
  	  // çµ¦é€™å¡Šå·§å…‹åŠ›ä¸€å€‹ç¸®æ”¾å‹•ç•«
  	  let scale = 1;
  	  let direction = -1; // å…ˆç¸®å°
  	  function bounce() {
  	    scale += direction * 0.05;
  	    piece.scale.set(scale, scale, scale);
  
  	    if (scale <= 0.8) {
  		  direction = 1; // åˆ°é”æœ€å° â†’ æ”¹æˆæ”¾å¤§
  	    }
  	    if (scale >= 1) {
  		  piece.scale.set(1, 1, 1); // å›åˆ°æ­£å¸¸å¤§å°
  		  return; // åœæ­¢å‹•ç•«
  	    }
  	    requestAnimationFrame(bounce);
  	  }
  	  bounce();
    }
  });
  
  let isRotating = true; // é è¨­æ—‹è½‰ä¸­
  const toggleBtn = document.getElementById("toggleRotate");

  toggleBtn.addEventListener("click", () => {
    isRotating = !isRotating; // åˆ‡æ›ç‹€æ…‹
    toggleBtn.innerText = isRotating ? "â¸ï¸" : "â–¶ï¸";
  });

  // ===============================
  // å‹•ç•«
  // ===============================
  function animate() {
    requestAnimationFrame(animate);
	
    if (isRotating) {
      pivot.rotation.y += 0.005;
    }
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // çª—å£ç¸®æ”¾
  window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
  
  const icon = document.getElementById("messageIcon");
  const msg = document.getElementById("message");

  icon.addEventListener("click", () => {
    msg.classList.toggle("show");
  });
</script>

</body>
</html>
